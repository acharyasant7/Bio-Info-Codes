#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Aug 16 14:54:14 2020

@author: sandesh
"""

import random
import math
    
def ProfileMatrix(motifs):
    A = []
    G= [] 
    C = [] 
    T = []
    Profile = []
    for i in range(0, len(motifs[0])):
         
        countA, countC, countG, countT = 0,0,0,0
         
        for motif in motifs:
            
            if motif[i] == 'A':
                countA = countA+1
            if motif[i] == 'C':
                countC = countC+1
            if motif[i] == 'G':
                countG = countG+1
            if motif[i] == 'T':
                countT = countT+1
                
        A.append((countA+1)/(4+len(motifs)))
        G.append((countG+1)/(4+len(motifs)))
        C.append((countC+1)/(4+len(motifs)))
        T.append((countT+1)/(4+len(motifs)))
     
    Profile.append(A)
    Profile.append(C)
    Profile.append(G)
    Profile.append(T)
    
    return Profile

def Probability_from_matrix(matrix,i,text):
    if text == 'A':
        return matrix[0][i]
    elif text == 'C':
        return matrix[1][i]
    elif text == 'G':
        return matrix[2][i]
    elif text == 'T':
        return matrix[3][i]


def Probability(pattern, Profile):
    P = 1.0
    for i in range(0, len(pattern)):
        P = P * Probability_from_matrix(Profile, i, pattern[i])
    return P

def Motifs_from_Profile(Profile, Dna, k):
    motifs = []
    
    for i in Dna:
        m = len(i) - k +1
        Prob = [0]*m
        for j in range(0,m):
            pattern = i[j: j+k]
            Prob[j] = Probability(pattern, Profile)
            
        for s in range(0,m):
            if Prob[s] == max(Prob):
                
                motifs.append(i[s: s+k])
                break
    return motifs

def FindConsensus(motifs):
    
    consensus = ""
    for i in range(len(motifs[0])):
        countA, countC, countG, countT = 0, 0, 0, 0
        for motif in motifs:
            if motif[i] == "A":
                countA += 1
            elif motif[i] == "C":
                countC += 1
            elif motif[i] == "G":
                countG += 1
            elif motif[i] == "T":
                countT += 1
        if countA >= max(countC, countG, countT):
            consensus += "A"
        elif countC >= max(countA, countG, countT):
            consensus += "C"
        elif countG >= max(countC, countA, countT):
            consensus += "G"
        elif countT >= max(countC, countG, countA):
            consensus += "T"
    return consensus

def HammingDist(pattern, text):
    count = 0
    for i in range(0, len(text)):
        if pattern[i] != text[i]:
            count = count +1
    return count

def Score(motifs):
    consensus = FindConsensus(motifs)
    score = 0
    for motif in motifs:
        score = score + HammingDist(motif, consensus)
    
    return score
def Random_Motif_Search(Dna, k, t):

    Motifs = []
    for i in Dna:
        m = random.randint(0, len(i)-k)
        Motifs.append(i[m : m+k])
    BestMotifs = Motifs
    min_score = Score(Motifs)
    while True:
        Profile = ProfileMatrix(Motifs)
        Motifs = Motifs_from_Profile(Profile,Dna,k)
        score = Score(Motifs)
        if score < min_score:
            BestMotifs = Motifs
            min_score = score
        else:
            return score, BestMotifs
        
Dna = ["CCACGCTATTACTAGCGACATCGACTTGAGAACGACGCAATCAACTCAGTTAATATCAAAGCCTGTATCCGGTGCAGTCCTCAAAGATACGGGTTAGTCTCCCGCTTCCACCCACCCCCCGACCTGCCCTATAGAGGGCCAATTGGACGAACTCCCACGCTATTACTAG",
"CGACATCGACTTGAGAACGGTTCTCTCATCCAGGACGCAATCAACTCAGTTAATATCAAAGCCTGTATCCGGTGCAGTCCTCAAAGATACGGGTTAGTCTCCCGCTTCCACCCACCCCCCGACCTGCCCTATAGAGGGCCAATTGGACGAACTCCCACGCTATTACTAG",
"CCCTCATTATAACGGAACACGACTACGTTCACGAGTGGGTCAGCTCATCCAGTTCAGTTAAATTACCGCCGCCAACCGGTGTACTCGTCGATTTACCTGATGTGAATTTACGGCTGATTCATACCACAGATTAACATAAGCGTTAATGGCGTGGGAGATGAATGCGAGG",
"TCCAGCCACTACACGCGAAACTACGGGCCCCAGAATGCATCGAATGTCTTCCTCCTGATGACCGCGGAAGACTCAAGTATTGACAGTTCTTATGTTGCCCAAGGATAAAAAGGCATAATACCGGCGTCCCTCAAGTCGGACGTAGAAGGTGGCCTCATCATCGGTACAG",
"CGAGACCCCATAGCAAAGCCATCGTGTGGTAGGAAAAGCAGCGGGTATTGAGCGCTCCCTGTTCACTCAGTAACTAATAACTTCGCTTAGTCGGACTCCTCATCCAGGACGCGGACGCCGTAGATTTCCCCCGTCCGAAAAACAAGACGCGGTTCGTTTCTGGGGTTGC",
"CCAATAGATGATTTACCAGGCGCCAACAAGCAATGGGTGGCCTGTCCCAGGGGTTAACCCGCTGCCCAAAAAATTCCATCTTTTCGATAATTAATGAGGATCTTGCGGATAGTAACCGACGTTGCGTATAAGAAGCTACCAACCTCCAATTGTCATTAAGCACGAGCTT",
"CGCTAGCCAAGTCGAGCGTGACTGGAACAAGTTCTACTTGTTGGACTGTGGTAGGATAGGTGTTTTCATCCAGCCTCATGGCGATCAATTCAACTAATCCGACCGTCAAATTTCGCCCAACGCCCCGCCTTGATACGCTCCAAAACCCCGCTATTCGGGTAACAGAAAA",
"GGTACGAGCGAGATTGAGGATCAGCTGTCTTAACTGTGGTCCATTCGATAGCAAGTCGCTCTGGGATTGCAAATAGTATCCTCAGTTGTTACTTCTAGCCTCAACCGAGTTAAGACGCCCGAGTTTGGGCCTCATCCAGGTTTGCAATCCAACTTGCTTGGTCCACGGG",
"AGCTACCTAGTGGCCGAGAGATTTCGTCCTCGAAGAGTGAACGAGTATTGGGCTTGTGCCAGCCAGTCGATCCCCGAATCTGATTATTTGTCTGGACGCTATTCCCGGGATTTCGTAAGGCATCCGATCTAGGCCGAGGTGGCGGAATCCAGTTACGGCTAGTTCAGAG",
"TGGCGTGTCAACGCCCTGGAATCTCTTGGCCTCATCCACAGTGAGCTGCCGAATTACGTATCAGGTGGGCCTGGCCATGCTGGCCGTGCGCTTACGGTCGTCATGGTCGCTGGCGTTGTGTACAGATTGTATACGATCTCGGAACCGTCGCCTAGATACGACACCTAAT",
"ATGATCGGACCGAAGATATCGTCTTACTGGTGTGTAAGTAATCGTTTTAGCGCGGTGAAAGAAGAACCCTAGTTAGTATGCTGGCTGCTTTTATACTCCGTGGTGGCCTCATTTCGATTTATGGGCGCCGGTCAATTGAAAATTTCTTTTGAGAGAGTGGAAAGGCTTA",
"CTGCCGCGTGGTAGAGCATACTTGATGCGATAACGTCACCAAGGGACCTCCGCTGCCGGGTATTGGGTGGCCATCTCCAGTAAAGTCCCGAACTAGTCTGGAAAGTCCAGTGGATGTAGCCTATGAATGCAGGTCCGAAGGGGTATGACACTTTGTACAGCTGTCCTCC",
"TAAGTCGGTGCGATCATCCAGGACGACCGAGAGTTTGCAAAGAGGCTACGCCGGGCTTAGATATGGCTGGCATCTTGGGTATTGTGGGGAAGTCCCCGTGACAGCATAGGCTACGCATGTTTGAGTCAATGGACAGAACCGTAAGGAATTGAGTTTTGTGGTGGTCAAA",
"ATCAGCGGCGGAACTTGGAAATGCCGAAACAAAGCGCCCACGGTGCTTGTACCAAGGTACTTAGTGGCTGGCGGCGCACGCCTCATCCAGATCGGAATTAGTTGTCCAATTTAGGACACCACTCAACCCAACGGCACCCTCAGTATTATGGAACCCGTACAAGCCGCTA",
"CTACGATAACAAGAGGTTGCCGTTTAGGTCGGATTGTAATCGACATCGTATCCAAGGGGAGCAGGGTGGGATGAAGATGCCGGGCGAGTTGGCCGTACATCTAATCACATGCTTGTGGTCCACTAACGCAATGAACCTGGGTGGTGACATCCAGGGGTGCATATCTATA",
"CCGAGAGCGTGCTAAACTACTATTGGTAGAATTGCTTGGGGTGGTTCCGACAGGATAGCTGCCTGAAGATGAACTAAGTCTCTGAGTCGGGTTGAGAGGGCGCCTCCCGCACAGAGCAGAAGTCGCGGTGGCAATATCCAGGAATCCCAGGTCTCAGGTATTGTGAGTC",
"CGTGCCTAATAGTATGCTATATGGTCTTTCACTCCCGTACCGTTTCACGCACTACTTCATTCCCGGTCCAGAGCTTGGCGGCTATGGGAGTTCTCCTATCAAAGAAAAAGACGAGGCCCCTTCGCCACGTATACCAAGGTGGCCTCAGGGAGATATCAAAACGTTTCAG",
"TCAGCAGTACCCTTACTTACAGCAGAGTGGCAGGGTTATGGATACGACCCTGATGGTGCGAGAGTGCCTGGAGAGAATCCGCACCCAGGAGCGGTATCGGAGAGGAGGGAAATTAGAGGCGTGGCCTCATCCGCACTTCCGTAATCACAAATGTTTCTACATGGCATAT",
"ATGGACACGTCAATGTTTTTGTTTGTGCATCAGTAGTGTTACGAAACCACGTTTGGTGGTGGCATCCAGCCAGAGCGTACGACGTCACAGGCAGCGGTGTTTAAGAGTTCCCACACCACTGAATAAATACAACTGATCCACTATGATGATGATGACCACCGCCCTACCC",
"GCTGCCCTACGGCGCCTTACGTCACAATGTTATAGTCAGGTGGGGTCACGTCCCTTGAACCCGTAGACCTGGACCTTCCGGACTCCTAGTTTCCTTCAGCGTTTGTTTCACCCCCCGCAGCTAACCGAGGTGGCCTCCCGCAGCTTACTTTGGGTGGAGGGTGACATAC"]


kmer = int(input("What is the k-mer?"))
t = len(Dna)
minscore = math.inf
for i in range(0,1000,1):
    score, motifs = Random_Motif_Search(Dna, kmer, t)
    if score < minscore:
        minscore = score
        best_motifs = motifs
print(best_motifs)
        
    