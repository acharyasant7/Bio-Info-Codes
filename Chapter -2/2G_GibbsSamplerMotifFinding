#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Aug 16 19:37:25 2020

@author: sandesh
"""
import random
import math
import operator
def ProfileMatrix(motifs):
    A = []
    G= [] 
    C = [] 
    T = []
    Profile = []
    for i in range(0, len(motifs[0])):
         
        countA, countC, countG, countT = 0,0,0,0
         
        for motif in motifs:
            
            if motif[i] == 'A':
                countA = countA+1
            if motif[i] == 'C':
                countC = countC+1
            if motif[i] == 'G':
                countG = countG+1
            if motif[i] == 'T':
                countT = countT+1
                
        A.append((countA+1)/(4+len(motifs)))
        G.append((countG+1)/(4+len(motifs)))
        C.append((countC+1)/(4+len(motifs)))
        T.append((countT+1)/(4+len(motifs)))
     
    Profile.append(A)
    Profile.append(C)
    Profile.append(G)
    Profile.append(T)
    
    return Profile

def Probability_from_matrix(matrix,i,text):
    if text == 'A':
        return matrix[0][i]
    elif text == 'C':
        return matrix[1][i]
    elif text == 'G':
        return matrix[2][i]
    elif text == 'T':
        return matrix[3][i]
def Probability(pattern, Profile):
    P = 1.0
    for i in range(0, len(pattern)):
        P = P * Probability_from_matrix(Profile, i, pattern[i])
    return P


def Profile_Randomly_genereated_kmer(Profile, motif,k):
    m = len(motif)-k+1
    Prob =[0]*m
    for j in range(0,m):
        pattern = motif[j:j+k]
        Prob[j] = Probability(pattern, Profile)
        
    normalizationTotal = sum(Prob)
    
    for i in range(0,m):
        Prob[i] = Prob[i]/normalizationTotal
    
    Prob = list(accumulate(Prob))
    
    randVal = random.random()
    
    for s in range(0,m):
        if randVal < Prob[s]:	
            break
    replacementKmer = motif[s:s+k]
   
    return replacementKmer
    

def accumulate(iterable, func=operator.add):
	
	it = iter(iterable)
	try:
		total = next(it)
	except StopIteration:
		return
	yield total
	for element in it:
		total = func(total, element)
		yield total
def FindConsensus(motifs):
    
    consensus = ""
    for i in range(len(motifs[0])):
        countA, countC, countG, countT = 0, 0, 0, 0
        for motif in motifs:
            if motif[i] == "A":
                countA += 1
            elif motif[i] == "C":
                countC += 1
            elif motif[i] == "G":
                countG += 1
            elif motif[i] == "T":
                countT += 1
        if countA >= max(countC, countG, countT):
            consensus += "A"
        elif countC >= max(countA, countG, countT):
            consensus += "C"
        elif countG >= max(countC, countA, countT):
            consensus += "G"
        elif countT >= max(countC, countG, countA):
            consensus += "T"
    return consensus

def HammingDist(pattern, text):
    count = 0
    for i in range(0, len(text)):
        if pattern[i] != text[i]:
            count = count +1
    return count

def Score(motifs):
    consensus = FindConsensus(motifs)
    score = 0
    for motif in motifs:
        score = score + HammingDist(motif, consensus)
    
    return score     
   
def GibbsSampler(Dna,k,t,N):
    Motifs = []
    for i in Dna:
        m = random.randint(0, len(i)-k)
        Motifs.append(i[m : m+k])
    BestMotifs = Motifs
    bestScore = Score(BestMotifs)
    for j in range(0,N,1):
        
        i = random.randint(0, t-1)
        Motifb = Motifs[:i] + Motifs[i+1 :]
        Profile = ProfileMatrix(Motifb)
        Motifs[i] = Profile_Randomly_genereated_kmer(Profile, Dna[i], k)
        score = Score(Motifs)
        
        if score < bestScore:
            bestScore = score
            BestMotifs = Motifs
    return bestScore, BestMotifs


Dna = ["TCTGGCTCTGAAGTCCATTACTCCGGAACGGGTAGCGCAATTATACCCGTAAAACCCTCTTTACATAATCGAGCGCCAGAGTGCGGGGCCCTTTGTGGATGGCCAGGCTACTGGATTACTTCGAGTTCATAAGAGTGTTGTTACAGTTCCGCGTTGAACTCTTAAAGACGTGGCAACGTTTTTGGTTCGTCCTGCTGCATCACATACGTATCACGAGGCATCAACAAGGAGAGCCGAGGGCCAGATAGTGAGATGTTGTCTTGTTTTCCAGTAGCGAAGGGTTCACTACGAGATTAACATAATTAGGAACTGGTCTGGCTCTGAAGTC",
"CATTACTCCGGAACGGGTAGCGCAATTATACCCGTAAAACCCTCTTTACATAATCGAGCGCCAGAGTGCGGGGCCCTTTGTGGATGGCCAGGCTACTGGATTACTTCGAGTTCATAAGAGTGTTGTTACAGTTCCGCGTTGAACTCTTAAAGACGTGGCAACGTTTTTGGTTCGTCCTGCTGCATCACATACGTATCACGAGGCATCAACAAGGAGAGCCGAGGGCCAGATAGTGAGATGTTTGTAATAAGATATCGGTCTTGTTTTCCAGTAGCGAAGGGTTCACTACGAGATTAACATAATTAGGAACTGGTCTGGCTCTGAAGTC",
"TCTCCCACGGGGTATGGCGACCTGCTATTGCGAGCGTCAATGACGGAGTACGCAGCACCGATTCACCTGGTAAAAGATATCGGGAGTGTCAGGCTTCGCCGGACTCGCGCAGTTTGAATGCTTACAGGGCCCACCCCGGAAATAGAGTGGACCGATACTGTAACGTGCAAACGCTGCTCCGGGGGCAGCAATATGAGATGTCACCCTTAGCATTTGACTGGGTTGGGCAGGATCTATGCTATCGCTAGCAGCTTACGCAGGCAATAACTCTTCCGGTCTTCGAACGGCGCATAAAATCGAAAGGCTGGGAACCCCGATAACTCGGTGG",
"TATACGGCCGTGAGGCTCCTCTACGCCTGCTTAATATTAAGATCGTCTAACAGCTAGGTACGACCACGGGGGGGATGGCCTCGGGCTATGCCCATCACGTGTCAGATGCTGGCTGTCTTCTTACTCCAATTACGAATCTGTAAGCGCGTGACACGGTACTTGCCTGTGAGACTAAAGTTGGGAAGATTAAGTTTTCTAGTTACTTAGGAGTTGCTTAGGGCATGACCCATAGGGGAACCCTGGTCGATAAAGGTGATCTTCGCAAAGATATCGTACGGCATTGAGCACCGCAATCGAACTGTCTAGCGGTAGGCGCACCACAACTCGG",
"GCTCGAAGTCAGTTGGATGGCGATGGCAAACTTGTTTCCGGATGATGGATGAATACGGTACTCCTTATAGCCCGCGTTCGAGGCCTAAGACGAGCCCCTTCATTTAGACTACAAGCACAAGTCACATGCGGAGACAGATAAAGTTTTTAATGAGACGGAAACGACTTGACTTAAGACGGGAACGGCGGAAACCCTGTCCAAAGATCCTGACGGTATCGTGACCAGACCGGAGGTTGGTCAGCTTAGAATAGCATGTGCTTTTCACCACAGGCGACTCATTCAGGTCTGTGAATCATAAGTCCTAACGAGCTTCTAGCGGTGAACTAAC",
"TGGGATCGCCGATTAAGCAGGAATCCGTGAAACTTGAAATGTGTTGGACACCCACATGGTACTGGATCACACGGGTTCTGGTGGCAGTACAATGTCCAAAGAATGCGCCTCAGTACCATACGCCGTCCTGGATTGTTTATCGTTTCTTTCCCATCATGGTCAAGTCCAATGGAAACTATGAAGGTGACCCAGCCCATTTTTAGGTGTAATCATTGGCCTCTGAGCTAGTTCCTCAGCTGTTTCGACACTATCGGTAACCCCTCCTTGGAGCACCCTACGGAAGTTCCGTCTGGCCATGTGGGTCAATCGTATTGTGCGTAGTTGGCTC",
"CTAGGCTCCCGCCCACCGCGTTACTCTTTCAGAGGGGGGAGCCGTCGGACGCCTGAGTTGGCACGCATTTACAGAGGTGACGTAACGGGGATTTTGTCTGCAGATATCGATTTTTAATAGGGTGTTGTCTTCTCTACACTGTGCGTATTGCAGCTTGATAGCGTGGGCGTGTTCGCATGGTAAAGGTCACTTGTCTCGTATTTGTGCGAGGATGGAATCCGCTACCCACAGGCGTATCGAGGAATTGCCCTCCCGCTGTTAAGAGATGCTAGTTGATCAATAACCGCTTACGCTGTCGTTGCTCTTATTGAGCCGTACATACACGTCA",
"CGCTTGTGTCTGGATCTTATCGATTGTAGCATGACGCATCGTAATAGAATTGCATTACCTATACTAAAGGCAAAAGGAGGTGTGTTATTGCCATCGCTCATGCAAGCGGCTTTTCTGGTGGAGGGACTTTGGGAGTTGATTTTTTACGAATTTACCGTAAGAACCGCGATGTTTATGAAACAAGCTACCTTTATCACGGATTGTTGTCGTGTCCAAAGTGCTCGGGTCGGTGCATGCTGACAATCGGGTATGTTGAGGCACAGGGAAACAAGAGACCCGCTATAGTCGCTCCAAAGATAAGTACGATAAAGACGCAGGCCAGGACATA",
"CTATATGAGCGCCAGAGATCCTGGCTTTTTCGTGGGGTAGACTTTCCGCTTTAGACCATCTGATCGCAGAGTATGGGTCAGTAGGTTTTTAGTCGATTTCGCCGCACTAGACATGTGGCTGCCGGCGCGCCGGCAGTAACGCACTGTTCTGTTAAGCGCTCTGTATCGCGCCCTCTACCCTGTAAGATTGGCCGGTTACATCAGCCCGCCTGACGCGTCGTAGGAATTGAGAATGATGCTCGGCAATAGGGGCCTCGATGTTTATTGAACTACCGGGATCATGTTCGTTTCTTCTTCGCCCCTATGTATGTCCTGTGATATCGGCAGG",
"ACTGTACCTAGAGGCGTAATATACCCTGTCATTCCAGGGACCAATAAGAGTCTCGGAGTCCAAGCAGCTCTACAGGATTTGGGCACGTGGCTAAGCGCCGCGCCCGCGCAGTACGCTACCTACTTAGACAACTCGTATGATCCGGAGATATAATAACACTATTAAGGCTTCTAGATTACGGAGATATTAGCACGTCTAAGTTATCGTGTCCAAAAGCATCGTCACAACGATTAGGGCGGATTATTGCGGGAATTGCCGCGCGAATCAATGCTCGTAGAACAGCCAAAGATCAACTAGTGGGCCCGAGTGCGGTATAGTAAAGGAGGTC",
"TTACGAAAGCATCACTTTCTCCCATCACGAAACGGATTCGACTTTCTAATGGCCGTGGACCGCCGGCGCTTACTCGTCCTGCGCGGCTCAGCTTGTCACGGATCTCGATATGCGAGTAGGCGATTACGCGCGTACCTGAAGCGCCTTCCCCAATAAGGATCAAAAGTACTCTTACGTCTGCAAACACCAGGGACGTCGAGAAGCGGCGCGCCTAAAACAGGTGCTGAGTTCGCCACAATACTTGAGGTTCTCTTTGGTGTTCCCGAGTGCCATGTCCAAAGATAGGCATGTAGTATCGCGTGATCATAAATACGTGCGGTCCTGTGTT",
"AGAAGATAGCAGGCTTTAATCGACCTCTAGCGAAAGTTCCAAAGATATCTATGTAGAGATACTGATCAATGCTCGCAGCAACCGGTCAACCCACTCCGTGACGATGATTGAGTGACGGCCGCGCTCTGTAGTAGATTCCAGTTCGGCGTACCATGGGTCTAGAGCTAGATCCAATCTATACGTCGGTTAGCTCGCATGTAACCTTTCTCACCTAGATCTAAGCTACTAAGTCAGTTGGCGAGAGATGCTTTTGCCGCGGCACCGTAGCCAAAGTCGTGAGAATACACTCCGCATCCTTATCGCGCGACAGGGTCAACCAAGACCTTGG",
"TGGGTGAATTGCGACTCGGCGGTGCTAAACCCAAAGATATCGACATCCGATCTTCCTAGTGACGGCTTTCACTTCGAACCAATTGAGTAAGGTCCCGGTTAGGCTACAAGCATTGAGCACGGAACAATCTAGCTAATGGGGTAGCTACACGTCCGTTTTGTGCACGGCTATATCGCCATACGTGTTGATGGTGCGGTCTCTGAAAGACAGACGACGTGTTAAGGGCCGCTCTCAGTCTGACCACAGGTTGTGCTGCAGCACCACTATCCCGACCACAGTGCTAATGGTTACAGAGCATCGTCGACCTCTCACCGCACTTGTCCCGTTC",
"CTGTGTAAATTGGTAATTAGTTCATAAGAACGGTAGGTGCCTCTCCACCTCCGATGGTCTCACTGTGGCATAGTAAATCAGAAACATAGATCTCTCACCTAGCTTGTTGGCTTCTGTCCAAGCCTATCGTGTGGTAAATTTGGGTCACGAATTGTTCTCCCAGGCGCATAGAATTAAAGAAACCGGCAGGTCCGCGCCACGCAATTAGAATGGAGAAGACGGCAACATTCAGAGCGGGCCGGCGGTTGGTAAGGACACCAATACGATTTTAACTAAGCCCTCGGTGCAATACCTTCGCAACAAGCGGCAGGGATTGACACTCGTCCTC",
"TTTATTCTTGTGTACCAACTCCTAAGGACGGTTACTTAATCAATGTTGGTACTCATCCATCCAGGAATTGCCTCACCCCTCCACAAGCTTTGAACATGGCAATCAACTGCAGCGAAGGCCTACATTTGCCTCCTAACCACCAGGCGTGTCGCCAGATATCGTTTCCTTATTGGCAATTCACTCTGGCAAATCATGAGGGGAGCTGGTCGTTATCACCCGCTCCTTCGGACTCTGTGCGCGAGATAAGCGGTAAGGACGAGTGCAGGAGTGTATCTGCCCTAACGGGACATCTCCGAGAGCTACTTAACCTGGTCGCCACCTGGATTAT",
"CCGTTCAGTTCTACACCGAACTTCGGTGCCTACACTCTTTCCACGTCTCTTGGACCAATACTCGGCGATTAGTGCTGGTTTGGACAAATCTCTGCACTAATTATGTGAGCCGTGGGTGGCGAAACGTACCCCGGATCAAGTGAACTTGTCCATGTATATCGTATTTCAGGGACCAACAGAGATGCGGTCCGGGGGTCTCGCTCGCCATCACTAAGGCAGATGGACGGGCCTTCCGGGGGAGATATCTCAGACGGTGCTAAGAAAGCACCACGCCGCTGTCCGATCGAGTGCGGAACTCCAGTAATCCGTGTGGAGCGACAACTTATCT",
"TAATAGACAGAACTTCGCTGCCCGTGGCAAATCTATCGTGCAGTTAATATCACGAATATACTCGTGGCCGCTGCTTCCCGGCCCAAAGTCTGACAACTCGACGATCACGGGTCACCTGATGAATGGTGCTACAAAGCATGGATAAATGACTTTCTGACGCTAGCGTTCAGCCATGGCAGTGCGATACAATGTGGCACCGAGGGGGGAACCCGTTACCTTCTGCTTCCAAACGATAGGGTACCCATGAATCATGTGTGAAGATATCGGCGTTTAATATCATCACGTTGTGGAAGGTCCATCCGGCGAGGATTTCCGTATGTACCTGTAT",
"GCTCAGTGGCTGGGTCGGAACATCAAACTGAACGAAGTTGCCTGCTGTTTTCGATGCGAAGACAGACTCGCAGAGCTAGATCTGCTAATCCGTACTTAAGGTATCATAATAACAGCCGTCTAGTAAATCAATGAGATTATCGTTTGGTCTAATCATCGCCCGTATGGGATTAGTTGGTACCGTGTCCACGGTCTCCTGACTATACGGGTCGCTCTCCCTCTGAATACCTGCTCCCTGTCACCCTACGTACGCCTTCTATTCAATATCACGAGAAGGCGACACTCGTCACGATGCTTATGATATGTCCGGGGATATCGCTGGCTAGCCC",
"CGTCCAAAGATATGAACACGTCCCCATATCTTAGTTGCATTTGCAGTAAACCAACTCGAATTTCACTAATTATGGTCTATCCTGGGCAGGTTTTACCGGGCTGACTACGAGTCTATATACTGTTTTGCACCTGCAGGGAACCTGCTGGCGTCCTAACGGGTGCGCCCCACACCGCGAAGCTGCAGATAACTAGTACGAGTTACCAATTGTTGAGGCGAGGTAGGTAACAGACTCGTCGTTATGGAAGGCCATTGCCCGAGGCGCCACTCGGATCTACTGGATTGTCGCGAACGCACCGAGTCCTTCCACATTTGAATCGGCGCGTATG",
"CCATACGACGCGCATCCAGTAACCTCCAGCACGCCAACTTCTGCAGGGCGAGGATTTACGGAGCTTGTGGGCTTTGTTTGCAGGTTTCTAAGTACACCTGTCTACAGAGGGCTGTAAGGGTTCTCTGGCGATACGCTGAAACCGGGACAGGGTGGACCCGGACTTCAGTCGACATCTCTGGGTAAAAGACGGTGCTCAAGGATGAGTGAGATTCCTAAGGTCCGCTGGGTGTTGAGCGTCGTGACTAATTAGGGTAGTCCCAATAGGAGTGCGCTCATGTCCATGCATATCGCTGGGGTGCGACTTGCGGTTAGGGTGACTCGAGGCC"]
N = 2000
k = 15
t = len(Dna)
minscore = math.inf
for i in range(0,20,1):
    score, motifs = GibbsSampler(Dna, k, t, N)
    if score < minscore:
        minscore = score
        best_motifs = motifs
print(best_motifs, minscore)
